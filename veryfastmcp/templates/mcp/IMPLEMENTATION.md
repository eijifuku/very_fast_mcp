# IMPLEMENTATION GUIDE (MCP server & tools)

This document is an implementation guide for implementing tools on the **MCP server skeleton** generated by `vfmcp new`.

## 0) Setup
```bash
vfmcp new my-mcp
cd my-mcp
pip install -e .[mcp]   # fastmcp / PyYAML
```

## 1) Startup (switching between stdio / http)
Edit the **run_options** in `configs/server.yaml` for startup configuration.
These are passed directly to **`mcp.run(**run_options)`** from `mcp_server.py`.

```yaml
# configs/server.yaml
run_options:
  transport: stdio
  # Example: for http
  # transport: http
  # host: 127.0.0.1
  # port: 8009
  # path: /mcp
```

```bash
python mcp_server.py   # default: stdio
```

## 2) Adding tools (generator)
```bash
vfmcp generate tool Search
```

The following will be generated:
```
mcp_app/tools/search.py
tests/test_search.py
```

Implement business logic in `mcp_app/tools/search.py` (template is `run(dict) -> Any`):

```python
# mcp_app/tools/search.py (example)
class SearchTool:
    """Business logic for 'search'."""
    
    # Tool basic information
    name = "search"
    description = "Search for documents or content"
    
    async def run(self, params: dict):
        query = (params or {}).get("query")
        if not query:
            raise ValueError("missing 'query'")
        # TODO: implement
        return {"results": [f"you searched: {query}"]}

**Important attributes:**
- `name`: Tool identifier (used when calling from MCP client)
- `description`: Tool description (displayed in MCP client tool list)
- `run()`: Main logic when tool is executed (async function)

## 3) Exposing to MCP (auto-registration or manual registration)
`mcp_server.py` has the following marker:
```python
# AUTO-REGISTER MARKER (do not remove): {VFMCP-AUTO-REGISTER}
```

When executing `vfmcp generate tool <Name>`, the CLI will **automatically append** the public function
right after this marker (with idempotency consideration).

If auto-registration is missing/failed, manually add the following to `mcp_server.py`:

```python
from mcp_app.tools.search import SearchTool

@mcp.tool(name="search")
async def search(**kwargs):
    return await SearchTool().run(kwargs)
```

> The public name is determined by `@mcp.tool(name="â€¦")`. It's easier to understand if the function name matches.

## 4) Testing
The skeleton includes a simple test for pytest. Add tests when adding tools.

```bash
pytest -q
```

Example (based on `tests/test_search.py`):
```python
import pytest
from mcp_app.tools.search import SearchTool

@pytest.mark.asyncio
async def test_search_ok():
    out = await SearchTool().run({"query": "hello"})
    assert "results" in out

@pytest.mark.asyncio
async def test_search_ng():
    with pytest.raises(ValueError):
        await SearchTool().run({})

## 5) Usage from client (examples)
- **stdio**: Register `python mcp_server.py` in Claude Desktop / MCP Inspector "startup command"
- **http**: Change `run_options.transport=http` and set `http://host:port/path` in MCP client remote connection

## 6) FAQ
- **Want strict input schema**  
  If adding dependencies is acceptable, introduce Pydantic. If keeping minimal configuration, manual validation at the beginning of `run()` is also OK.
- **Want to change tool name or public name**  
  Business logic class name is arbitrary. Public name is changed by modifying `@mcp.tool(name="...")`.
- **Multiple tools**  
  Repeat `vfmcp generate tool Xxx` and add `@mcp.tool` to `mcp_server.py` (automatically appended if auto-registration is enabled).
